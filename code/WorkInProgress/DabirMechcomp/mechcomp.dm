//TODO:
// - Stun and ghost checks for the verbs
// - Buttons can be picked up with the hands full. Woops.
// - Message Datum pooling and recycling.
// - Maybe distance-limit connections? They're a bit silly right now.
// - Individually removable connections if possible.
// -- Can certainly bring up a list of human-readable identifiers with not too much effort.
// -- Difficulty is then associating those identifiers with the connection itself.

//Important Notes:
//
//Please try to always re-use incoming signals for your outgoing signals.
//Just modify the message of the incoming signal and send it along.
//This is important because each message keeps track of which nodes it traveled trough.
//It's through that list that we can prevent infinite loops. Or at least try to.
//(People can probably still create infinite loops somehow. They always manage)
//Always use the newMessage proc of the sending object when creating a new message.

//How Inputs Work Now
//Name all input procs as input1, input2, input3 etc, make sure the sequence is unbroken.
//Each proc's final parameter should be "getName=0".
//Each proc's first line should be
//if getName return "input name here"

//The main difference between these and old mechcomps is that settings are now set with inputs rather than verbs.
//This is because you can now trigger inputs with multitools.

/*
/datum/mech_message
	var
		signal
		list/nodes
	proc
		addNode(obj/item/mechcomp/H)
		removeNode(obj/item/mechcomp/H)
		hasNode(obj/item/mechcomp/H)
		isTrue()

/datum/mech_message
	var
		var/signal = "1"						The signal transmitted as part of the message.
		list/nodes = list()						List of all nodes the message has travelled through to prevent infinite loops.

	proc
		addNode(obj/item/mechcomp/H)		Possibly unnecessary procs.
		removeNode(obj/item/mechcomp/H)	Do exactly what they say on the tin.
		hasNode(obj/item/mechcomp/H)		Very, very simple.
		isTrue()								Returns 1 if the signal is 1, "1", "true" or "one", because BYOND has no bools.

/obj/item/mechcomp
	var
		under_floor = 0									Whether the component is under the floor or not.
		list/particles									All the mechanics particles that are attached to the component.

		announcements = 0								Whether the component announces changes to settings.
		list/inputs										List of possible inputs for the component. Generated by New().
		list/connections_in								List of connections coming into the component, not used often but important.
		list/connections_out							List of connections leaving component and which input they're going to.

	proc
		newMessage(var/sig)								Creates a new mech_message with signal set to the given string.
		cloneMessage(mech_message/msg)					Duplicates a message, including its node list.
		chooseInput()									Brings up a prompt to choose an input from the object's list.
		fireInput(var/num, var/datum/mech_message/msg)	Fires the input given by number.
		fireAllOutgoing(var/datum/mech_message/msg)		Fires all outgoing connections.
		wipeIncoming()									Clears the list of incoming connections and removes self from all outgoing.
		wipeOutgoing()									Clears the list of outgoing connections and removes self from all incoming.
		hasMultitool(var/mob/M)							Returns 1 if the mob has a multitool handy (either hand or cyborg module).
		canChange(var/mob/M)							Returns 1 if the mob qualifies to alter a component's connections.
		dropConnect(obj/item/mechcomp/O, null, var/src_location, var/control_orig, var/control_new, var/params)
														Handles connecting on drag and drop.

		cutParticles()									Removes all particles attached to the component.
		toggleAnchor()									Anchors or unanchors the component, also updates the icon.
		checkFloor(var/intact)							Checks whether the component is under a floor or not.
		updateIcon()									Updates the component's icon. Will be unique to each component.
		componentSay(var/string)						Has the component speak a string in a machiney way (beeps, squawks, etc).
		getReadout(var/obj/item/device/multitool/T)		Provides a complete readout of the component's settings with a multitool icon.

	verb
		wipe											Verb to disconnect all connections while leaving component in place.
		toggleAnnounce									announcements = !announcements
*/

#define MECH_LOOP "<span style=\"color:red\">You cannot create a direct loop between two components.</span>"
#define MECH_DUPE "<span style=\"color:red\">You cannot create multiple connections between the same components.</span>"
#define MECH_NOINPUT "<span style=\"color:red\">[end.name] has no input slots. Can not connect [start.name] as Trigger.</span>"
#define MECH_CONNECTED "<span style=\"color:green\">You connect the [start.name] to the [end.name].</span>"

//Global list of telepads so we don't have to loop through the entire world aaaahhh.
var/list/mechcomp_telepads = new/list()

/datum/mech_message
{
	//Contents of the message.
	var/signal = "1"

	//List of nodes through which the signal has passed, for infinite loop prevention.
	var/list/nodes = list()

	proc/addNode(obj/item/mechcomp/H)
	{
		nodes.Add(H)
	}

	proc/removeNode(obj/item/mechcomp/H)
	{
		nodes.Remove(H)
	}

	proc/hasNode(obj/item/mechcomp/H)
	{
		return nodes.Find(H)
	}

	//Thanks for not having bools, byond.
	proc/isTrue()
	{
		if (isnum(signal) && signal == 1)
		{
			return 1
		}

		else if(istext(signal))
		{
			if(lowertext(signal) == "true" || lowertext(signal) == "1" || lowertext(signal) == "one")
			{
				return 1
			}
		}

		else
		{
			return 0
		}
	}
}

// The component itself.
/obj/item/mechcomp
{
	name = "MechComp base item"
	icon = 'icons/misc/mechanicsExpansion.dmi'
	icon_state = "comp_unk"

	//Physical vars
	anchored = 0
	flags = FPRINT | EXTRADELAY | TABLEPASS | CONDUCT
	w_class = 1.0
	var/under_floor = 0
	var/list/particles = new/list()

	//Signal vars
	var/announcements = 0
	var/list/inputs = new/list()
	var/list/connections_out = new/list()
	var/list/connections_in = new/list()

	New()
	{
		//Build the list of input names for humans to read.
		for(var/i = 1, !hascall(src, "input" + i), i++)
		{
			//End result should be a list like (1 = "toggle", 2 = "turn off", 3 = "turn on")
			inputs[i] = call("input" + i)(getName = 1)
		}
		return ..()
	}

	get_desc(var/dist, var/usr)
	{
		var/tool = hasMultitool()									// Find a multitool if you have one.
		if(dist <= 1 && tool)										// If there's a tool and you're next to the component,
		{
			. += getReadout() ? "<br>" + bicon(tool) + getReadout() : ""// if there's a readout, it's appended to the description.
		}
	}

	pickup()
	{
		if(!anchored)
		{
			wipeIncoming()
			wipeOutgoing()
			return ..()
		}
		else
		{
			return
		}
	}

	dropped()
	{
		wipeIncoming()
		wipeOutgoing()
		return ..()
	}

	MouseDrop(obj/O, null, var/src_location, var/control_orig, var/control_new, var/params)
	{
		if(istype(O, /obj/item/mechcomp))								// Connections can only go to other mechcomps.
		{
			if(anchored && O.anchored)										// Both ends have to be anchored.
			{
				if(canChange(usr))												// The user has to be able to change connections.
				{
					dropConnect(O, null, src_location, control_orig, control_new, params)
					return ..()
				}
			}
			else
			{
				boutput(usr, "<span style=\"color:red\">Both components need to be secured into place before they can be connected.</span>")
			}
		}
		else
		{
			boutput(usr, "<span style=\"color:red\">The [O.name] is not compatible with MechComp connections.</span>")
		}
		return
	}

	// Can only pick up the component if it's loose and you're not a robot.
	attack_hand(mob/user as mob)
	{
		if(anchored == 0 || !issilicon(user))
		{
			return ..(user)
		}
		else
		{
			return
		}
	}

	// AI has the same reaction as anyone else.
	attack_ai(mob/user as mob)
	{
		return src.attack_hand(user)
	}

	/*
	Takes an object and a mob to be using the object.
	A wrench will attach or detach any component.
	A multitool will fire an input using the multitool's pre-programmed signal.
	*/
	attackby(obj/item/W as obj, mob/user as mob)
	{
		if(istype(W, /obj/item/wrench))
		{
			return toggleAnchor()
			logTheThing("station", usr, src, "placed a %target% at [showCoords(src.x, src.y, src.z)]")
		}
		else if(istype(W,/obj/item/device/multitool) && anchored)
		{
			var/selected_input = chooseInput()

			if(!selected_input)
			{
				return 1
			}
			else
			{
				fireInput(selected_input, newMessage(W:signalstring))
				return 1
			}
		}
		else
		{
			return 0
		}
	}

	process()
	{
		// If dislodged by a black hole or something, cut connections.
		if(!anchored)
		{
			wipeIncoming()
			wipeOutgoing()
			processing_items.Remove(src) // And remove it from processing until toggleAnchor() re-adds it.
		}
		// If it's disconnected or under the floor it shouldn't be showing particles.
		if(!anchored || under_floor)
		{
			cutParticles()
			return
		}

		// Otherwise, update the particles.
		if(particles.len != connections_out.len)
		{
			cutParticles()
			for(var/atom/X in connections_out)
			{
				particles.Add(particleMaster.SpawnSystem(new /datum/particleSystem/mechanic(src.loc, X.loc)))
			}
		}
		return
	}

	//Signal procs

	//ALWAYS use this to create new messages!!!
	proc/newMessage(var/sig)
	{
		var/datum/mech_message/message = new/datum/mech_message
		message.signal = sig
		return message
	}

	/*
	Takes one mech_message.
	Returns a new copy of that mech_message, nodes included.
	Use this to avoid passing one message to two nodes which might simultaneously modify it.
	*/
	proc/cloneMessage(var/datum/mech_message/msg)
	{
		var/datum/mech_message/msg2 = newMessage(msg.signal)
		msg2.nodes = msg.nodes.Copy()
		return msg2
	}

	/*
	Brings up a prompt to choose an input from the component's input list, plus an option to cancel proceedings.
	Returns the position of the input chosen, or 0 if *CANCEL* or a mysterious invalid input are chosen.
	*/
	proc/chooseInput()
	{
		return inputs.Find(input(usr, "Select \"[src]\" Input", "Input Selection") in inputs + "*CANCEL*")
	}

	/*
	Takes a number and a mech_message.
	If the component has an input with that number, fires it using the mech_message and returns 1.
	Otherwise returns 0.
	*/
	proc/fireInput(var/num, var/datum/mech_message/msg)
	{
		var/to_call = "input" + num
		if (hascall(src, to_call))
		{
			spawn(1) call(to_call)(msg)
			return 1
		}
		return 0
	}

	/*
	Takes one mech_message.
	For each valid outgoing connection, sends the given message or a duplicate to the input specified by that connection.
	Returns the number of messages sent.
	*/
	proc/fireAllOutgoing(var/datum/mech_message/msg)
	{
		var/messagesSent = 0								// Counts the number of messages forwarded.

		if(!msg.hasNode(src))								// We only forward messages if this component isn't in the node list.
		{
			msg.addNode(src)									// Add this component to the message's node list.

			for(var/obj/item/mechcomp/M in connections_out)		// For each outgoing connection,
			{
				if(!messagesSent)									// if we haven't sent anything yet,
				{
					M.fireInput(connections_out[M], msg)				// pass on the original message.
				}
				else												// Otherwise,
				{
					M.fireInput(connections_out[M], cloneMessage(msg))	// make and send a copy.
				}
				messagesSent++										// Either way, increment the number of messages sent.
			}
		}
		return messagesSent										// Not currently used for anything but could be useful later.
	}

	/*
	Deletes all incoming connections at both ends.
	*/
	proc/wipeIncoming()
	{
		for(var/obj/item/mechcomp/M in connections_in)		// For each item in the incoming connections,
		{
			M.connections_out.Remove(src)							// remove this component from its list of outgoing
			connections_in.Remove(M)								// and remove the item from the incoming list.
		}

		return
	}

	/*
	Deletes all outgoing connections at both ends.
	*/
	proc/wipeOutgoing()
	{
		for(var/obj/item/mechcomp/M in connections_out)	// For each item in the outgoing connections,
		{
			M.connections_in.Remove(src)							// remove this component from its list of incoming
			connections_out.Remove(M)								// and remove the item from the outgoing list.
		}
		return
	}

	/*
	Takes one mob.
	Returns the first multitool found in their left hand, right hand or in a cyborg module.
	*/
	proc/hasMultitool(var/mob/M)
	{
		if(hasvar(M, "l_hand") && istype(M:l_hand, /obj/item/device/multitool))
		{
			return M:l_hand
		}
		if(hasvar(M, "r_hand") && istype(M:r_hand, /obj/item/device/multitool))
		{
			return M:r_hand
		}
		if(hasvar(M, "module_states"))
		{
			for(var/atom/A in M:module_states)
			{
				if(istype(A, /obj/item/device/multitool))
				{
					return A
				}
			}
		}

		return 0
	}

	/*
	Takes one mob.
	Returns true if the mob meets all conditions for changing the component's connections.
	If they don't, and verbose is true, explains why to them.
	*/
	proc/canChange(var/mob/M, var/verbose=1)
	{
		if (!istype(usr, /mob/living) || usr.stat)	// User must be a living mob and not be unconscious or dead.
		{
			if(verbose) boutput(usr, "<span style=\"color:red\">You're in no condition to do that!</span>")
			return
		}
		else
		{
			if(!hasMultitool(M))
			{
				if(verbose) boutput(usr, "<span style=\"color:red\">You need a multitool to change connections or settings.</span>")
				return 0
			}
			else
			{
				return 1
			}
		}
	}

	/*
	Called by MouseDrop when one mechcomp is dragged onto another.
	If there's no reason why the two components shouldn't be connected, connects them.
	Otherwise tells the user why the connection wasn't made.
	Unless it's because the user cancelled in the middle.
	*/
	proc/dropConnect(obj/item/mechcomp/O, null, var/src_location, var/control_orig, var/control_new, var/params)
	{
		if(O == src)							// If you're trying to connet a component to itself,
		{
			boutput(usr, "<span style=\"color:red\">You cannot connect a component to itself.</span>")
			return									// then abort.
		}

		else									// Otherwise,
		{
			var/obj/item/mechcomp/start				// This contains the start of the connection.
			var/obj/item/mechcomp/end				// This contains the end of it.

			// User chooses which way they want the connection to go.
			switch (input(usr, "Use [src] as:", "Connection Direction") in list("Trigger", "Receiver", "*CANCEL*"))
			{
				if("*CANCEL*")							// If they decided not to proceed,
				{
					return									// Then we're done.
				}
				if("Trigger")							// If they want this component to be a trigger, it's an outgoing connection.
				{
					start = src								// It starts with this component,
					end = O									// and it ends with that one.
				}
				if("Receiver")							// If they want this component to be a receiver, it's an incoming connection.
				{
					start = O								// It starts with that component,
					end = src								// and it ends with this one.
				}
			}

			// Now that we've established which is the start and which is the end, or given up, we can get to work.
			if (start.connections_out.Find(end))				// If there's already a connection from start to end,
			{
				boutput(usr, MECH_DUPE)					// then tell the user not to make duplicate connections
				return											// and abort.
			}

			if(start.connections_in.Find(end))					// If there's already a conection from end to start,
			{
				boutput(usr, MECH_LOOP)					// then tell the user not to make direct loops
				return											// and abort.
			}

			if(end.inputs.len)									// If the end of the connection has inputs,
			{
				var/selected_input = end.chooseInput()				// then have the user choose one of its inputs to connect to.

				if(selected_input)									// If they did pick an input,
				{
					start.connections_out.Add(end)						// then add the connection to start's outgoing.
					start.connections_out[end] = selected_input			// Note which input of the component we connect to.
					end.connections_in.Add(start)						// And then add it to end's incoming.
					boutput(usr, MECH_CONNECTED)
				}
				else												// If they didn't choose an input (should mean picked *CANCEL*),
				{
					return												// then abort.
				}

			}
			else												// Otherwise,
			{
				boutput(usr, MECH_NOINPUT)					// Let the user know that the end has no inputs.
				return												// And abort.
			}
		}
	}

	//Removes all mechanics particles attached to the component, for when it's unsecured, disconnected, under the floor etc.
	proc/cutParticles()
	{
		if(particles.len)
		{
			for(var/datum/particleSystem/mechanic/M in particles)
			{
				M.Die()
			}
			particles.Cut()
		}

		return
	}

	proc/toggleAnchor()
	{
		switch(anchored)
		{
			if(0)
			{
				if(!isturf(src.loc))
				{
					boutput(usr, "<span style=\"color:red\">[src] needs to be on the ground for that to work.</span>")
					return 0
				}

				boutput(usr, "You attach the [src] to the underfloor and activate it.")
				anchored = 1

				// Now that the component's anchored, add it to the list of items to process.
				if (!(src in processing_items)) processing_items.Add(src)
			}
			if(1)
			{
				boutput(usr, "You detach the [src] from the underfloor and deactivate it.")
				anchored = 0
			}
		}

		under_floor = checkFloor()
		updateIcon()

		wipeIncoming()
		wipeOutgoing()
		return 1
	}

	/*
	Checks the component's location and whether it's attached to it.
	Returns 1 if the component's location is a valid turf, the turf is intact and the component is anchored to it.
	Returns 0 otherwise.
	*/
	proc/checkFloor()
	{
		var/turf/T = src.loc

		if(isturf(T))
		{
			return (T.intact && anchored)
		}
		else
		{
			return 0
		}
	}

	/*
	In theory, update the icon's status.
	Right now this is unique to each individual component.
	*/
	proc/updateIcon()
	{
		return
	}

	/*
	Takes a string.
	Has the component speak that string audibly, using one of a variety of verbs.
	*/
	proc/componentSay(var/string)
	{
		string = trim(sanitize(html_encode(string)), 1)
		if(string)
		{
			for(var/mob/O in all_hearers(7, src.loc))
			{
				O.show_message("<span class='game radio'><span class='name'>[src]</span><b> [bicon(src)] [pick("squawks", "beeps", "boops", "says", "screeches")], </b> <span class='message'>\"[string]\"</span></span>",2)
			}
		}
	}

	/*
	Provides a complete readout of the component's settings etc.
	*/
	proc/getReadout()
	{
	}

	// Verb to disconnect all connections.
	verb/wipe()
	{
		set src in view(1)
		set name = "\[Disconnect all\]"
		set desc = "Disconnects all devices connected to this device."
		set category = "Local"

		if(canChange(usr))
		{
			wipeIncoming()
			wipeOutgoing()

			boutput(usr, "<span style=\"color:blue\">You disconnect [src].</span>")
		}
		return
	}

	verb/toggleAnnounce()
	{
		set src in view(1)
		set name = "\[Toggle Announcements\]"
		set desc = "Toggles announcements of changes to component settings."
		set category = "Local"

		if(canChange(usr))
		{
			announcements = !announcements
			componentSay("Announcements toggled [announcements ? "on" : "off"].")
		}
	}
}